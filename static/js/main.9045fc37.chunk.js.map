{"version":3,"sources":["lib/ui/View.js","lib/ui/Graphics.js","components/PitchTimeChart.js","App.js","index.js"],"names":["View","PureComponent","constructor","props","margin","top","right","bottom","left","rowSpan","columnSpan","canResizeRows","canResizeColumns","super","onResize","increaseRows","this","state","rowlimit","outerHeight","viewSize","newSpan","viewHeight","setState","height","decreaseRows","increaseColumns","columnLimit","outerWidth","viewWidth","width","decreaseColumns","close","toggleView","name","getSizeControlHTML","className","onClick","title","disabled","icon","faArrowsAltV","faLongArrowAltUp","faArrowsAltH","faLongArrowAltLeft","faTimesCircle","resizeComponent","additionalState","ow","oh","setupCanvas","canvas","dpr","window","devicePixelRatio","rect","getBoundingClientRect","ctx","getContext","scale","drawNoteTrapezoid","x","y","height2","beginPath","moveTo","lineTo","closePath","fill","PitchTimeChart","componentDidMount","initialize","overviewHeight","yAxisLabelType","svg","select","selectAll","remove","scaleLinear","range","xOv","yOv","xAxis","axisBottom","yAxis","axisLeft","tickFormat","d","Midi","getMidiNoteByNr","label","xAxisEl","append","attr","call","yAxisEl","text","highlightCanvas","initialized","drawNotes","notes","boxHeight","veloScale","domain","note","startPos","start","endPos","end","xPos","h","velocity","pitch","Math","max","draw","selectedTrack","showAllTime","midiFileData","timeSelection","clearRect","ctx2","track","allNotes","length","Utils","flattenArray","min","extent","xDomain","interval","low","high","tracks","drawRowBandsForSharps","drawMeasures","colors","schemeCategory10","boxHeight2","forEach","tr","i","fillStyle","fillRect","clipLeftRight","drawTimeSelection","drawCurrentPlayerTime","oldFill","rowHeight","isSharp","yPos","xmlFileData","part","parts","p","measureLinePositions","pos","currentPlayerTime","xOv1","xOv2","x1","x2","handleBrushed","e","brushStartEvent","setTimeSelection","startX","offsetX","startY","offsetY","endX","nativeEvent","startTime","invert","endTime","minTime","maxTime","clipValue","sorted","swapSoSmallerFirst","liveNotes","componentDidUpdate","render","style","gridArea","ref","n","onMouseDownCapture","onMouseUpCapture","transform","onChange","target","value","key","Array","map","_","background","faToggleOn","faToggleOff","App","Component","floor","innerWidth","innerHeight","similarSections","addEventListener","source","document","getElementById","_this","MidiParser","parse","obj","preprocessMidiFileData","noteObjs","alert","s","type","id","href","faGithub","ReactDOM"],"mappings":"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","file":"static/js/main.9045fc37.chunk.js","sourcesContent":["import React, { PureComponent } from \"react\";\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faArrowsAltH, faArrowsAltV, faLongArrowAltLeft, faLongArrowAltUp, faTimesCircle } from '@fortawesome/free-solid-svg-icons';\r\n\r\nexport default class View extends PureComponent {\r\n\r\n    /**\r\n     * @param {Props} props props\r\n     * @param {Obbject} margin margin\r\n     * @param {number} rowSpan number of rows this view initially has\r\n     * @param {number} colSpan number of columns this view initially has\r\n     * @param {boolean} canResizeRows allow to resize rows?\r\n     * @param {boolean} canResizeColumns allow to resize columns?\r\n     */\r\n    constructor(\r\n        props,\r\n        margin = { top: 0, right: 0, bottom: 0, left: 0 },\r\n        rowSpan = 1,\r\n        columnSpan = 1,\r\n        canResizeRows = true,\r\n        canResizeColumns = true,\r\n    ) {\r\n        super(props);\r\n        const { outerWidth, outerHeight } = props.viewSize;\r\n        const viewWidth = outerWidth * columnSpan;\r\n        const viewHeight = outerHeight * rowSpan;\r\n        this.state = {\r\n            rowSpan,\r\n            columnSpan,\r\n            canResizeRows,\r\n            canResizeColumns,\r\n            rowlimit: 12,\r\n            columnLimit: 2,\r\n            outerWidth,\r\n            outerHeight,\r\n            viewHeight,\r\n            viewWidth,\r\n            margin,\r\n            width: (outerWidth * columnSpan) - margin.left - margin.right,\r\n            height: (outerHeight * rowSpan) - margin.top - margin.bottom,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Views shoud overwrite this method,\r\n     * to react to resizing.\r\n     * This method is called by resizeComponent (see below).\r\n     */\r\n    onResize = () => { }\r\n\r\n    /**\r\n     * Resizes the component by updating the width and height depending on\r\n     * the received outerWidth and outerHeight props and the internal margin.\r\n     * After updating the state, the callback function will be called.\r\n     * @param {Object} component\r\n     * @param {Function} callback\r\n     * @param {Object} additionalState other properties to set in the state\r\n     */\r\n    resizeComponent(additionalState = {}) {\r\n        const { outerWidth, outerHeight } = this.props.viewSize;\r\n        const { outerWidth: ow, outerHeight: oh, margin, rowSpan, columnSpan } = this.state;\r\n        if (ow !== outerWidth || oh !== outerHeight) {\r\n            const viewWidth = outerWidth * columnSpan;\r\n            const viewHeight = outerHeight * rowSpan;\r\n            this.setState(\r\n                {\r\n                    ...additionalState,\r\n                    outerWidth,\r\n                    outerHeight,\r\n                    viewWidth,\r\n                    viewHeight,\r\n                    width: (outerWidth * columnSpan) - margin.left - margin.right,\r\n                    height: (outerHeight * rowSpan) - margin.top - margin.bottom,\r\n                },\r\n                this.onResize\r\n            );\r\n        }\r\n    }\r\n\r\n    increaseRows = () => {\r\n        const { rowSpan, rowlimit, margin, canResizeRows } = this.state;\r\n        const { outerHeight } = this.props.viewSize;\r\n        if (!canResizeRows) { return; }\r\n        if (rowSpan >= rowlimit) { return; }\r\n        const newSpan = rowSpan + 1;\r\n        const viewHeight = outerHeight * newSpan;\r\n        this.setState(\r\n            {\r\n                rowSpan: newSpan,\r\n                viewHeight,\r\n                height: viewHeight - margin.top - margin.bottom\r\n            },\r\n            this.onResize\r\n        );\r\n    }\r\n\r\n    decreaseRows = () => {\r\n        const { rowSpan, margin, canResizeRows } = this.state;\r\n        const { outerHeight } = this.props.viewSize;\r\n        if (!canResizeRows) { return; }\r\n        if (rowSpan <= 1) { return; }\r\n        const newSpan = rowSpan - 1;\r\n        const viewHeight = outerHeight * newSpan;\r\n        this.setState(\r\n            {\r\n                rowSpan: newSpan,\r\n                viewHeight,\r\n                height: viewHeight - margin.top - margin.bottom\r\n            },\r\n            this.onResize\r\n        );\r\n    }\r\n\r\n    increaseColumns = () => {\r\n        const { columnSpan, columnLimit, margin, canResizeColumns } = this.state;\r\n        const { outerWidth } = this.props.viewSize;\r\n        if (!canResizeColumns) { return; }\r\n        if (columnSpan >= columnLimit) { return; }\r\n        const newSpan = columnSpan + 1;\r\n        const viewWidth = outerWidth * newSpan;\r\n        this.setState(\r\n            {\r\n                columnSpan: newSpan,\r\n                viewWidth,\r\n                width: viewWidth - margin.left - margin.right\r\n            },\r\n            this.onResize\r\n        );\r\n    }\r\n\r\n    decreaseColumns = () => {\r\n        const { columnSpan, margin, canResizeColumns } = this.state;\r\n        const { outerWidth } = this.props.viewSize;\r\n        if (!canResizeColumns) { return; }\r\n        if (columnSpan <= 1) { return; }\r\n        const newSpan = columnSpan - 1;\r\n        const viewWidth = outerWidth * newSpan;\r\n        this.setState(\r\n            {\r\n                columnSpan: newSpan,\r\n                viewWidth,\r\n                width: viewWidth - margin.left - margin.right\r\n            },\r\n            this.onResize\r\n        );\r\n    }\r\n\r\n    close = () => {\r\n        const { toggleView, name } = this.props;\r\n        if (toggleView && name) {\r\n            toggleView(name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the HTML (JSX) for the view size control buttons\r\n     */\r\n    getSizeControlHTML = () => (\r\n        <div className='sizeControl'>\r\n            {this.state.canResizeRows && (\r\n                <span>\r\n                    <button\r\n                        onClick={this.increaseRows\r\n                        }\r\n                        title={'Increase rows'}\r\n                        disabled={this.state.rowSpan >= this.state.rowlimit}\r\n                    >\r\n                        <FontAwesomeIcon icon={faArrowsAltV} />\r\n                    </button >\r\n                    <button\r\n                        onClick={this.decreaseRows}\r\n                        title={'Decrease rows'}\r\n                        disabled={this.state.rowSpan <= 1}\r\n                    >\r\n                        <FontAwesomeIcon icon={faLongArrowAltUp} />\r\n                    </button>\r\n                </span>\r\n            )}\r\n            {this.state.canResizeColumns && (\r\n                <span>\r\n                    <button\r\n                        onClick={this.increaseColumns}\r\n                        title={'Increase columns'}\r\n                        disabled={this.state.columnSpan >= this.state.columnLimit}\r\n                    >\r\n                        <FontAwesomeIcon icon={faArrowsAltH} />\r\n                    </button>\r\n                    <button\r\n                        onClick={this.decreaseColumns}\r\n                        title={'Decrease columns'}\r\n                        disabled={this.state.columnSpan <= 1}\r\n                    >\r\n                        <FontAwesomeIcon icon={faLongArrowAltLeft} />\r\n                    </button>\r\n                </span>\r\n            )}\r\n            <button\r\n                onClick={this.close}\r\n                title={'Close'}\r\n            >\r\n                <FontAwesomeIcon icon={faTimesCircle} />\r\n            </button>\r\n        </div >\r\n    );\r\n}\r\n","import { Utils } from \"musicvis-lib\";\nimport { curveMonotoneX, curveLinear, line } from \"d3-shape\";\nimport { scaleLinear } from \"d3-scale\";\nimport { extent, max } from \"d3-array\";\n\n\n/**\n * Sets up a canvas rescaled to device pixel ratio\n * From https://www.html5rocks.com/en/tutorials/canvas/hidpi/\n * @param {HTMLCanvasElement} canvas canvas element\n * @returns {CanvasRenderingContext2D} canvas rendering context\n */\nexport function setupCanvas(canvas) {\n    // Get the device pixel ratio, falling back to 1.\n    var dpr = window.devicePixelRatio || 1;\n    // Get the size of the canvas in CSS pixels.\n    var rect = canvas.getBoundingClientRect();\n    // Give the canvas pixel dimensions of their CSS\n    // Size times the device pixel ratio.\n    canvas.width = rect.width * dpr;\n    canvas.height = rect.height * dpr;\n    var ctx = canvas.getContext('2d');\n    // Scale all drawing operations by the dpr, so you\n    // don't have to worry about the difference.\n    ctx.scale(dpr, dpr);\n    return ctx;\n}\n\n\n/**\n * Draws horizontal bands with alternating color to better distinguish rows.\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {number} rowHeight height of bnote boxes\n */\nexport function drawRowBands(ctx, margin, rows, rowHeight, width, fillStyle = 'rgba(128, 128, 128, 0.1)') {\n    const oldFill = ctx.fillStyle;\n    ctx.fillStyle = fillStyle;\n    const xPos = margin.left;\n    for (let i = 0; i < rows; i += 2) {\n        const yPos = margin.top + rowHeight * i;\n        ctx.fillRect(xPos, yPos, width, rowHeight);\n    }\n    ctx.fillStyle = oldFill;\n}\n\n/**\n * Draws a bar chart.\n * @param {CanvasRenderingContext2D} ctx canvas context\n * @param {number} x x position\n * @param {number} y y position\n * @param {number} width width\n * @param {number} height height\n * @param {number} maxVal maximum value towards the chart values are scaled\n * @param {number[]} values values to draw bars for\n * @param {string[]} colors color for each value entry\n */\nexport function drawBarChart(ctx, x, y, width, height, maxVal, values, colors) {\n    const w = width / values.length;\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        ctx.fillStyle = colors[i];\n        const h = (value / maxVal) * height;\n        const yPos = y + height - h;\n        ctx.fillRect(x + i * w, yPos, w - 2, h);\n    }\n}\n\n/**\n * Draws a stacked bar chart.\n * @param {CanvasRenderingContext2D} ctx canvas context\n * @param {number} x x position\n * @param {number} y y position\n * @param {number} width width\n * @param {number} height height\n * @param {number} maxVal maximum value towards the chart values are scaled\n * @param {number[]} values values to draw bars for\n * @param {string[]} colors color for each value entry\n */\nexport function drawStackedBarChart(ctx, x, y, width, height, maxVal, values, colors) {\n    let currentSum = 0;\n    // Stack values\n    for (let i = values.length - 1; i >= 0; i--) {\n        currentSum += values[i];\n        values[i] = currentSum;\n    }\n    for (let i = 0; i < values.length; i++) {\n        const val = values[i];\n        ctx.fillStyle = colors[i];\n        const h = (val / maxVal) * height;\n        const yPos = y + height - h;\n        ctx.fillRect(x, yPos, width, h);\n    }\n}\n\n/**\n * Draws a horizontal boxplot onto a canvas.\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {Object} margin width {top, right, left, bottom}\n * @param {Function} x D3 linear scale\n * @param {number} yPos y position\n * @param {number} plotHeight height of the plot\n * @param {number[]} data array of numbers to draw the boxplot for\n * @param {boolean} drawOutliers if true, outliers will be drawn as dots\n * @param {string} fillBox color for the box\n * @param {string} fillWhisk color for the whiskers\n */\nexport function drawBoxplot(\n    ctx,\n    margin,\n    x,\n    yPos,\n    plotHeight,\n    data,\n    drawOutliers = false,\n    fillBox = 'rgba(70, 130, 180, 0.8)',\n    fillWhisk = 'steelblue'\n) {\n    const { q1, q2, q3, r0, r1 } = Utils.getBoxplotCharacteristics(data);\n    // Get positions\n    const q1Pos = margin.left + x(q1);\n    const q2Pos = margin.left + x(q2);\n    const q3Pos = margin.left + x(q3);\n    const r0Pos = margin.left + x(r0);\n    const r1Pos = margin.left + x(r1);\n    const yCenter = yPos + plotHeight / 2;\n    // Box (with a gap for the median)\n    ctx.fillStyle = fillBox;\n    ctx.fillRect(q1Pos, yPos, q2Pos - q1Pos - 1, plotHeight);\n    ctx.fillRect(q2Pos + 1, yPos, q3Pos - q2Pos - 1, plotHeight);\n    ctx.fillStyle = fillWhisk;\n    // Left whisker\n    ctx.fillRect(r0Pos, yPos, 1, plotHeight);\n    ctx.fillRect(r0Pos, yCenter, q1Pos - r0Pos, 1);\n    // Right whisker\n    ctx.fillRect(r1Pos, yPos, 1, plotHeight);\n    ctx.fillRect(q3Pos, yCenter, r1Pos - q3Pos, 1);\n    // Draw outliers\n    if (drawOutliers) {\n        const outliers = data.filter(d => d < r0 || d > r1);\n        for (let ol of outliers) {\n            ctx.fillRect(margin.left + x(ol), yCenter, 2, 2);\n        }\n    }\n}\n\n/**\n * Draws a kernel density estimation (KDE) area chart for each pitch.\n * TODO: draw mean and quartiles like in a box plot\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {Object} margin width {top, right, left, bottom}\n * @param {Function} x D3 linear scale\n * @param {number} yPos y position\n * @param {number} plotHeight height of the plot\n * @param {number[]} data array of numbers to draw the boxplot for\n * @param {boolean} smooth turn smoothing on and off\n * @param {string} fillStyle fill color\n * @param {number} bandwidth kernel bandwidth\n * @param {number} ticks number of ticks for which to compute a curve point\n */\nexport function drawKdeAreaChart(ctx, margin, x, yPos, plotHeight, data, smooth = true, fillStyle, bandwidth = 0.5, ticks = 100) {\n    const kde = Utils.kernelDensityEstimator(Utils.kernelEpanechnikov(bandwidth), x.ticks(ticks));\n    const estimate = kde(data);\n    // Force 0 for y value at start and end for correct drawing\n    estimate.unshift([estimate[0][0], 0]);\n    estimate.push([estimate[estimate.length - 1][0], 0]);\n    const y = scaleLinear()\n        .domain(extent(estimate, d => d[1]))\n        .range([yPos + plotHeight, yPos]);\n    // Smoothed or linearly interpolated area\n    const lineGenerator = line()\n        .x(d => margin.left + x(d[0]))\n        .y(d => y(d[1]))\n        .curve(smooth ? curveMonotoneX : curveLinear)\n        .context(ctx);\n    ctx.beginPath();\n    lineGenerator(estimate);\n    ctx.closePath();\n    ctx.fillStyle = fillStyle;\n    ctx.fill();\n}\n\n/**\n * Draws a violinplot (a mirrored KDE area chart).\n * TODO: draw mean and quartiles like in a box plot\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {Object} margin width {top, right, left, bottom}\n * @param {Function} x D3 linear scale\n * @param {number} yPos y position\n * @param {number} plotHeight height of the plot\n * @param {number[]} data array of numbers to draw the boxplot for\n * @param {boolean} smooth turn smoothing on and off\n * @param {string} fillStyle fill color\n * @param {number} bandwidth kernel bandwidth\n * @param {number} ticks number of ticks for which to compute a curve point\n */\nexport function drawViolinPlot(ctx, margin, x, yPos, plotHeight, data, smooth = true, fillStyle, bandwidth = 0.5, ticks = 100) {\n    const kde = Utils.kernelDensityEstimator(Utils.kernelEpanechnikov(bandwidth), x.ticks(ticks));\n    const estimate = kde(data);\n    // Force 0 for y value at start and end for correct drawing\n    estimate.unshift([estimate[0][0], 0]);\n    estimate.push([estimate[estimate.length - 1][0], 0]);\n    const maxEst = max(estimate, d => d[1]);\n    const y = scaleLinear()\n        .domain([-maxEst, maxEst])\n        .range([yPos + plotHeight, yPos]);\n    // Smoothed or linearly interpolated area\n    const lineGeneratorTop = line()\n        .x(d => margin.left + x(d[0]))\n        .y(d => y(d[1]))\n        .curve(smooth ? curveMonotoneX : curveLinear)\n        .context(ctx);\n    const lineGeneratorBottom = line()\n        .x(d => margin.left + x(d[0]))\n        .y(d => y(-d[1]))\n        .curve(smooth ? curveMonotoneX : curveLinear)\n        .context(ctx);\n    ctx.fillStyle = fillStyle;\n    ctx.beginPath();\n    lineGeneratorTop(estimate);\n    ctx.closePath();\n    ctx.fill();\n    ctx.beginPath();\n    lineGeneratorBottom(estimate);\n    ctx.closePath();\n    ctx.fill();\n}\n\n\n/**\n  * Draws a drum note shape to the canvas.\n  * @param {CanvasRenderingContext2D} ctx canvas context\n  * @param {string} shape one of [triangle, <>, x, o, ostroke, xstroke]\n  * @param {number} x x position\n  * @param {number} y y position\n  * @param {number} size size (width and height of the symbols outer bounds)\n  */\nexport function drawDrumNoteShape(ctx, shape, x, y, size) {\n    const halfSize = size * 0.4;\n    switch (shape) {\n        case 'triangle':\n            drawTriangle(ctx, x, y, halfSize);\n            break;\n        case '<>':\n            drawDiamond(ctx, x, y, halfSize);\n            break;\n        case 'x':\n            drawX(ctx, x, y, halfSize);\n            break;\n        case 'o':\n            drawFilledCircle(ctx, x, y, halfSize);\n            break;\n        case 'ostroke':\n            drawFilledCircle(ctx, x, y, halfSize);\n            ctx.lineWidth = 2;\n            ctx.beginPath();\n            ctx.moveTo(x - halfSize, y - halfSize);\n            ctx.lineTo(x + halfSize, y + halfSize);\n            ctx.stroke();\n            ctx.lineWidth = 1;\n            break;\n        case 'xstroke':\n            drawX(ctx, x, y, halfSize);\n            ctx.lineWidth = 3;\n            ctx.beginPath();\n            ctx.moveTo(x - halfSize, y);\n            ctx.lineTo(x + halfSize, y);\n            ctx.stroke();\n            ctx.lineWidth = 1;\n            break;\n        default:\n            console.warn(`Unsupported shape ${shape}`);\n    }\n}\n\n/**\n * Draws a stroked circle.\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {number} x x coordinate of center\n * @param {number} y y coordinate of center\n * @param {number} radius radius\n */\nexport function drawCircle(ctx, x, y, radius) {\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, 2 * Math.PI);\n    ctx.stroke();\n}\n\n/**\n * Draws a filled circle.\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {number} x x coordinate of center\n * @param {number} y y coordinate of center\n * @param {number} radius radius\n */\nexport function drawFilledCircle(ctx, x, y, radius) {\n    if (radius < 0) {\n        console.error(`Cannot draw circle with negative radius of ${radius}`);\n    }\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, 2 * Math.PI);\n    ctx.fill();\n}\n\n/**\n * Draws a filled triangle like this: /\\\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {number} x x coordinate of center\n * @param {number} y y coordinate of center\n * @param {number} halfSize half of the size\n */\nexport function drawTriangle(ctx, x, y, halfSize) {\n    ctx.beginPath();\n    ctx.moveTo(x - halfSize, y + halfSize);\n    ctx.lineTo(x + halfSize, y + halfSize);\n    ctx.lineTo(x, y - halfSize);\n    ctx.closePath();\n    ctx.fill();\n}\n\n/**\n * Draws a diamond like this: <>\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {number} x x coordinate of center\n * @param {number} y y coordinate of center\n * @param {number} halfSize half of the size\n */\nexport function drawDiamond(ctx, x, y, halfSize) {\n    ctx.beginPath();\n    ctx.moveTo(x - halfSize, y);\n    ctx.lineTo(x, y - halfSize);\n    ctx.lineTo(x + halfSize, y);\n    ctx.lineTo(x, y + halfSize);\n    ctx.closePath();\n    ctx.fill();\n}\n\n/**\n * Draws an X\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {number} x x coordinate of center\n * @param {number} y y coordinate of center\n * @param {number} halfSize half of the size\n */\nexport function drawX(ctx, x, y, halfSize) {\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(x - halfSize, y - halfSize);\n    ctx.lineTo(x + halfSize, y + halfSize);\n    ctx.moveTo(x - halfSize, y + halfSize);\n    ctx.lineTo(x + halfSize, y - halfSize);\n    ctx.stroke();\n    ctx.lineWidth = 1;\n}\n\n/**\n * Draws a trapezoid that looks like a rectangle but gets narrower at the right\n * end, so better show where one ends and the next begins.\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {number} x x coordinate of top left\n * @param {number} y y coordinate of top left\n * @param {number} width width\n * @param {number} height height (of left side)\n * @param {number} height2 height (of right side)\n */\nexport function drawNoteTrapezoid(ctx, x, y, width, height, height2) {\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x, y + height);\n    ctx.lineTo(x + width, y + (height / 2 + height2 / 2));\n    ctx.lineTo(x + width, y + (height / 2 - height2 / 2));\n    ctx.closePath();\n    ctx.fill();\n}\n\n/**\n * Draws a trapezoid that looks like a rectangle but gets narrower at the top\n * end, so better show where one ends and the next begins.\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {number} x x coordinate of bounding rect's top left\n * @param {number} y y coordinate of bounding rect's top left\n * @param {number} width width (of bounding rect / bottom side)\n * @param {number} height height\n * @param {number} width2 width (of top side)\n */\nexport function drawNoteTrapezoidUpwards(ctx, x, y, width, height, width2) {\n    ctx.beginPath();\n    ctx.lineTo(x, y + height);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x + (width / 2 + width2 / 2), y);\n    ctx.lineTo(x + (width / 2 - width2 / 2), y);\n    ctx.closePath();\n    ctx.fill();\n}\n\n/**\n * Draws an arc that connects similar parts.\n * Both parts must have the same width in pixels.\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {number} startX1 x coordinate of the start of the first part\n * @param {number} startX2 x coordinate of the start of the second part\n * @param {number} length length in pixels of the parts\n * @param {number} yBottom bottom baseline y coordinate\n */\nexport function drawArc(ctx, startX1, startX2, length, yBottom) {\n    // Get center and radius\n    const radius = (startX2 - startX1) / 2;\n    const cx = startX1 + radius + length / 2;\n    ctx.lineWidth = length;\n    ctx.beginPath();\n    ctx.arc(cx, yBottom, radius, Math.PI, 2 * Math.PI);\n    ctx.stroke();\n}\n\n/**\n * Draws a more complex path and fills it.\n * Two arcs: One from startX1 to endX2 on the top, one from endX1 to startX2\n * below it.\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {number} startX1 x coordinate of the start of the first part\n * @param {number} endX1 x coordinate of the end of the first part\n * @param {number} startX2 x coordinate of the start of the second part\n * @param {number} endX2 x coordinate of the end of the second part\n * @param {number} endX2 x coordinate of the end of the second part\n * @param {number} yBottom bottom baseline y coordinate\n */\nexport function drawAssymetricArc(ctx, startX1, endX1, startX2, endX2, yBottom) {\n    // Get center and radius\n    const radiusTop = (endX2 - startX1) / 2;\n    if (radiusTop < 0) {\n        return;\n    }\n    let radiusBottom = (startX2 - endX1) / 2;\n    if (radiusBottom < 0) {\n        radiusBottom = 0;\n    }\n    const cxTop = startX1 + radiusTop;\n    const cxBottom = endX1 + radiusBottom;\n    ctx.beginPath();\n    ctx.moveTo(startX1, yBottom);\n    ctx.arc(cxTop, yBottom, radiusTop, Math.PI, 2 * Math.PI);\n    ctx.lineTo(startX2, yBottom);\n    ctx.arc(cxBottom, yBottom, radiusBottom, 2 * Math.PI, Math.PI, true);\n    ctx.closePath();\n    ctx.fill();\n}\n\n/**\n * Draws a line indicating the current player time\n * @param {number} currentPlayerTime current player time in seconds\n * @param {Function} x D3 scaleLinear for x axis\n */\nexport function drawCurrentTimeIndicator(ctx, currentPlayerTime, x, height, margin) {\n    if (currentPlayerTime === null) {\n        return;\n    }\n    const xPos = margin.left + x(currentPlayerTime) - 1;\n    ctx.fillRect(xPos, margin.top, 2, height);\n}\n\n/**\n * Clips left and right of a visualization by clearing parts of the canvas.\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {Object} margin {top, right, bottom, left}\n * @param {number} width width of the area to clip around\n * @param {number} height height of the clipping area\n */\nexport function clipLeftRight(ctx, margin, width, height) {\n    ctx.clearRect(0, margin.top, margin.left, height);\n    ctx.clearRect(margin.left + width, margin.top, margin.right, height);\n}\n\n/**\n * Draws measure lines and tempo and beat type information\n * @param {CanvasRenderingContext2D} ctx canvas rendering context\n * @param {Object} parsedXml parsed MusicXML data\n * @param {Object} margin {top, right, bottom, left}\n * @param {number} width width\n * @param {number} height height\n * @param {Function} x D3 linear scale\n */\nexport function drawMusicXmlInformation(ctx, parsedXml, margin, width, height, x) {\n    // Draw measure lines\n    ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';\n    for (let i = 0; i < parsedXml.measureLinePositions.length; i++) {\n        const line = parsedXml.measureLinePositions[i];\n        const xPos = x(line);\n        // Do not draw invisible lines\n        if (xPos < 0) { continue; }\n        if (xPos > width) { break; }\n        const pos = margin.left + xPos;\n        ctx.fillRect(pos, margin.top, 2, height);\n        // Draw measure number\n        if ((i + 2) % 4 === 0) {\n            ctx.fillStyle = '#888';\n            ctx.fillText(i + 2, pos + 10, margin.top);\n            ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';\n        }\n    }\n    const xOffs = margin.left + 15;\n    ctx.fillStyle = '#888';\n    // Draw tempo changes\n    for (let t of parsedXml.tempoChanges) {\n        ctx.fillText(`${t.tempo} bpm`, xOffs + x(t.time), margin.top - 20);\n    }\n    // Draw beatType changes\n    for (let b of parsedXml.beatTypeChanges) {\n        ctx.fillText(`${b.beats} / ${b.beatType}`, xOffs + x(b.time), margin.top - 8);\n    }\n}\n","import React from 'react';\r\nimport { scaleLinear } from 'd3-scale';\r\nimport { extent } from 'd3-array';\r\nimport { axisBottom, axisLeft } from 'd3-axis';\r\nimport { select } from 'd3-selection';\r\nimport View from '../lib/ui/View';\r\nimport { Utils, Midi } from 'musicvis-lib';\r\nimport { schemeCategory10 } from 'd3-scale-chromatic';\r\nimport { drawNoteTrapezoid, setupCanvas, clipLeftRight } from '../lib/ui/Graphics';\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faToggleOn, faToggleOff } from '@fortawesome/free-solid-svg-icons';\r\n\r\n\r\nexport default class PitchTimeChart extends View {\r\n\r\n    constructor(props) {\r\n        const margin = { top: 35, right: 20, bottom: 40, left: 55 };\r\n        super(props, margin);\r\n        this.state = {\r\n            ...this.state,\r\n            overviewHeight: 80,\r\n            showAllTime: false,\r\n            selectedTrack: 'all',\r\n            // pitch, note, drums\r\n            yAxisLabelType: 'pitch',\r\n            boxHeight: null,\r\n            notes: [],\r\n            liveNotes: [],\r\n        };\r\n    }\r\n\r\n    componentDidMount = () => this.initialize();\r\n\r\n    onResize = () => this.initialize();\r\n\r\n    componentDidUpdate() {\r\n        this.resizeComponent();\r\n        if (this.state.initialized) {\r\n            this.draw();\r\n        }\r\n    }\r\n\r\n    initialize = () => {\r\n        const { width, height, overviewHeight, yAxisLabelType } = this.state;\r\n        const svg = select(this.svg);\r\n        svg.selectAll('*').remove();\r\n        // Scales\r\n        const x = scaleLinear().range([2, width]);\r\n        const xOv = scaleLinear().range([2, width]);\r\n        const y = scaleLinear().range([height, overviewHeight + 25]);\r\n        const yOv = scaleLinear().range([overviewHeight, 0]);\r\n        // Axes\r\n        const xAxis = axisBottom(x);\r\n        const yAxis = axisLeft(y);\r\n        if (yAxisLabelType === 'note') {\r\n            yAxis.tickFormat(d => Midi.getMidiNoteByNr(d)?.label);\r\n        }\r\n        const xAxisEl = svg.append('g')\r\n            .attr('class', 'axis')\r\n            .attr('transform', `translate(0, ${height})`)\r\n            .call(xAxis);\r\n        const yAxisEl = svg.append('g')\r\n            .attr('class', 'axis')\r\n            .call(yAxis);\r\n        // Labels\r\n        svg.append('text')\r\n            .attr('class', 'yAxisLabel')\r\n            .text('Pitch')\r\n            .attr('transform', `rotate(90) translate(${(height + overviewHeight) / 2}, ${45})`);\r\n        // Setup canvas rescaled to device pixel ratio\r\n        setupCanvas(this.canvas);\r\n        setupCanvas(this.highlightCanvas);\r\n        this.setState({ initialized: true, svg, x, xOv, y, yOv, xAxis, yAxis, xAxisEl, yAxisEl });\r\n    }\r\n\r\n    /**\r\n     * Draws the note retangles.\r\n     * @param {CanvasRenderingContext2D} ctx canvas rendering context\r\n     * @param {Notes[]} notes notes with start, end, pitch\r\n     * @param {number} boxHeight height of each pitch-line\r\n     * @param {Function} x D3 linearScale x scale\r\n     * @param {Function} y D3 linearScale y scale\r\n     */\r\n    drawNotes = (ctx, notes, boxHeight, x, y) => {\r\n        const { width, margin } = this.state;\r\n        const veloScale = scaleLinear()\r\n            .domain([0, 127])\r\n            .range([boxHeight * 0.1, boxHeight]);\r\n        for (let note of notes) {\r\n            const startPos = x(note.start);\r\n            const endPos = x(note.end);\r\n            // Do not draw invisible notes\r\n            if (endPos < 0 || startPos > width) {\r\n                continue;\r\n            }\r\n            const xPos = margin.left + startPos;\r\n            // TODO: encode velocity in height?\r\n            const h = veloScale(note.velocity);\r\n            const yPos = margin.top + y(note.pitch) - h / 2;\r\n            const w = Math.max(endPos - startPos, 1);\r\n            drawNoteTrapezoid(ctx, xPos, yPos, w, h, h / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main drawing function\r\n     */\r\n    draw = () => {\r\n        const { viewWidth, viewHeight, margin, width, height, overviewHeight, x, xOv, y, yOv, xAxis, yAxis, xAxisEl, yAxisEl, selectedTrack, showAllTime } = this.state;\r\n        const { midiFileData, timeSelection } = this.props;\r\n        // Prepare main and highlight canvas\r\n        const ctx = this.canvas.getContext('2d');\r\n        ctx.clearRect(0, 0, viewWidth, viewHeight);\r\n        const ctx2 = this.highlightCanvas.getContext('2d');\r\n        ctx2.clearRect(0, 0, viewWidth, viewHeight);\r\n\r\n        // Get notes\r\n        let track;\r\n        let allNotes = [];\r\n        if (midiFileData && midiFileData.length > 0) {\r\n            if (selectedTrack === 'all') {\r\n                // Show all tracks\r\n                allNotes = Utils.flattenArray(midiFileData);\r\n            } else {\r\n                // Show selected track\r\n                track = Math.min(selectedTrack, midiFileData.length - 1);\r\n                allNotes = midiFileData[track];\r\n            }\r\n\r\n        }\r\n        if (allNotes.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Set x scale domain\r\n        const [start, end] = extent(allNotes, d => d.end);\r\n        const xDomain = [start < 0 ? start : 0, end];\r\n        xOv.domain(xDomain);\r\n        if (showAllTime) {\r\n            // Show all notes\r\n            x.domain(xDomain);\r\n        } else {\r\n            let interval = [0, end];\r\n            if (timeSelection) {\r\n                interval = timeSelection;\r\n            }\r\n            x.domain(interval);\r\n        }\r\n        xAxisEl.call(xAxis);\r\n        // Set y scale domain\r\n        const [low, high] = extent(allNotes, d => d.pitch);\r\n        y.domain([+low - 1, +high + 1]);\r\n        yOv.domain([+low - 1, +high + 1]);\r\n        yAxisEl.call(yAxis);\r\n        // If only one track, use color for channels\r\n        // and allow to only show a single channel\r\n        let tracks = selectedTrack === 'all' ? midiFileData : [midiFileData[track]];\r\n\r\n        // Draw background bands and measure lines\r\n        this.drawRowBandsForSharps(ctx, margin, y, low, high, width, 'rgba(128, 128, 128, 0.15)');\r\n        this.drawMeasures(ctx);\r\n\r\n        // Draw notes onto canvas\r\n        const colors = schemeCategory10;\r\n        const boxHeight = height / (high - low + 3);\r\n        const boxHeight2 = overviewHeight / (high - low + 1);\r\n        tracks.forEach((tr, i) => {\r\n            ctx.fillStyle = colors[i % colors.length];\r\n            this.drawNotes(ctx, tr, boxHeight, x, y);\r\n            this.drawNotes(ctx, tr, boxHeight2, xOv, yOv);\r\n        });\r\n\r\n        // Separator between overview and main visualization\r\n        ctx.fillStyle = '#888';\r\n        ctx.fillRect(margin.left, margin.top + overviewHeight + 12, width, 1);\r\n        clipLeftRight(ctx, margin, width, height);\r\n\r\n        // Draw time selection and similar sections\r\n        if (timeSelection) {\r\n            const [start, end] = timeSelection;\r\n            this.drawTimeSelection(ctx2, start, end, 'rgba(70, 130, 180, 0.2)');\r\n        }\r\n        // Draw current player time\r\n        this.drawCurrentPlayerTime(ctx2);\r\n    }\r\n\r\n    /**\r\n     * Draws horizontal bands with alternating color to better distinguish rows.\r\n     * @param {CanvasRenderingContext2D} ctx canvas rendering context\r\n     */\r\n    drawRowBandsForSharps = (ctx, margin, y, low, high, width, fillStyle = 'rgba(128, 128, 128, 0.1)') => {\r\n        const oldFill = ctx.fillStyle;\r\n        ctx.fillStyle = fillStyle;\r\n        const rowHeight = y(0) - y(1);\r\n        const xPos = margin.left;\r\n        for (let pitch = low - 1; pitch <= high + 1; pitch++) {\r\n            // Only draw for shaprs\r\n            if (Midi.isSharp(pitch)) {\r\n                const yPos = margin.top + y(pitch) - rowHeight / 2;\r\n                ctx.fillRect(xPos, yPos, width, rowHeight);\r\n            }\r\n        }\r\n        ctx.fillStyle = oldFill;\r\n    }\r\n\r\n    /**\r\n     * Draws measure lines (not on the overview)\r\n     * @param {CanvasRenderingContext2D} ctx canvas rendering context\r\n     */\r\n    drawMeasures = (ctx) => {\r\n        const { xmlFileData, selectedTrack } = this.props;\r\n        const { margin, width, height, overviewHeight, x } = this.state;\r\n        if (!xmlFileData) { return; }\r\n        const part = xmlFileData.parts[selectedTrack === 'all' ? 0 : selectedTrack];\r\n        ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';\r\n        const yPos = margin.top + overviewHeight + 20;\r\n        const h = height - overviewHeight - 20;\r\n        for (let p of part.measureLinePositions) {\r\n            const pos = x(p);\r\n            if (pos <= 0 || pos > width) { continue; }\r\n            ctx.fillRect(margin.left + pos, yPos, 1, h);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the current player time (from props) onto the highlight canvas.\r\n     */\r\n    drawCurrentPlayerTime = (ctx) => {\r\n        const { margin, height, overviewHeight, x, xOv } = this.state;\r\n        const { currentPlayerTime } = this.props;\r\n        if (currentPlayerTime === null) { return; }\r\n        ctx.fillStyle = 'steelblue';\r\n        ctx.fillRect(margin.left + xOv(currentPlayerTime), margin.top, 2, overviewHeight);\r\n        ctx.fillRect(margin.left + x(currentPlayerTime), margin.top + overviewHeight + 25, 2, height - overviewHeight - 25);\r\n    }\r\n\r\n    /**\r\n     * Draws the current time selection (from props) onto the highlight canvas.\r\n     */\r\n    drawTimeSelection = (ctx, start, end, fill) => {\r\n        const { margin, height, overviewHeight, x, xOv } = this.state;\r\n        ctx.fillStyle = fill;\r\n        const xOv1 = margin.left + xOv(start);\r\n        const xOv2 = margin.left + xOv(end);\r\n        ctx.fillRect(xOv1, margin.top, xOv2 - xOv1, overviewHeight);\r\n        const x1 = margin.left + x(start);\r\n        const x2 = margin.left + x(end);\r\n        ctx.fillRect(x1, margin.top + overviewHeight + 25, x2 - x1, height - overviewHeight - 25);\r\n    }\r\n\r\n    /**\r\n     * Sets the new player start time\r\n     * @param {MouseEvent} e React onClick event\r\n     */\r\n    handleBrushed = (e) => {\r\n        const { margin, overviewHeight, xOv, brushStartEvent } = this.state;\r\n        const { setTimeSelection } = this.props;\r\n        if (!e || !brushStartEvent) { return; }\r\n        const { offsetX: startX, offsetY: startY } = brushStartEvent;\r\n        const { offsetX: endX } = e.nativeEvent;\r\n        // See if start position is in overview\r\n        if (startY < margin.top || startY > margin.top + overviewHeight) {\r\n            return;\r\n        }\r\n        // Get time\r\n        let startTime = xOv.invert(startX - margin.left);\r\n        let endTime = xOv.invert(endX - margin.left);\r\n        // Clip to domain\r\n        const [minTime, maxTime] = xOv.domain();\r\n        startTime = Utils.clipValue(startTime, minTime, maxTime);\r\n        endTime = Utils.clipValue(endTime, minTime, maxTime);\r\n        const sorted = Utils.swapSoSmallerFirst(startTime, endTime);\r\n        // Make selection at least 1 second wide\r\n        if (sorted[1] - sorted[0] < 1) {\r\n            sorted[1] = sorted[0] + 1;\r\n        }\r\n        // Set selection in App.js\r\n        setTimeSelection(sorted);\r\n    }\r\n\r\n    render() {\r\n        const { viewWidth, viewHeight, margin } = this.state;\r\n        const { midiFileData, selectedTrack } = this.props;\r\n        // HTML\r\n        return (\r\n            <div\r\n                className='View PitchTimeChart'\r\n                style={{ gridArea: `span ${this.state.rowSpan} / span ${this.state.columnSpan}` }}\r\n            >\r\n                <canvas\r\n                    className='ViewCanvas'\r\n                    ref={n => this.canvas = n}\r\n                    style={{ width: viewWidth, height: viewHeight }}\r\n                    onMouseDownCapture={(e) => this.setState({ brushStartEvent: e.nativeEvent })}\r\n                    onMouseUpCapture={this.handleBrushed}\r\n                />\r\n                <canvas\r\n                    className='ViewCanvas HighlightCanvas'\r\n                    ref={n => this.highlightCanvas = n}\r\n                    style={{ width: viewWidth, height: viewHeight }}\r\n                />\r\n                <svg\r\n                    width={viewWidth}\r\n                    height={viewHeight}\r\n                >\r\n                    <text\r\n                        className='heading'\r\n                        x={viewWidth / 2}\r\n                        y={20}\r\n                    >\r\n                        MIDI Piano Roll\r\n                    </text>\r\n                    <g\r\n                        ref={n => this.svg = n}\r\n                        transform={`translate(${margin.left}, ${margin.top})`}\r\n                    />\r\n                    <text\r\n                        className='yAxisLabel'\r\n                        x={viewWidth / 2}\r\n                        y={viewHeight - 5}\r\n                    >\r\n                        Time in seconds\r\n                    </text>\r\n                </svg>\r\n                <div className='viewControls'>\r\n                    <select\r\n                        title='MIDI track(s)'\r\n                        onChange={(e) => this.setState({ selectedTrack: e.target.value })}\r\n                        disabled={midiFileData.length > 1 && selectedTrack === 'all'}\r\n                    >\r\n                        <option key='all' value='all'>All tracks</option>\r\n                        {new Array(midiFileData.length).fill(0).map((_, i) => (\r\n                            <option\r\n                                key={i}\r\n                                value={i}\r\n                                style={{ background: schemeCategory10[i % schemeCategory10.length] }}\r\n                            >\r\n                                Track {i}\r\n                            </option>\r\n                        ))}\r\n                    </select>\r\n                    <select\r\n                        title='Y-axis labels'\r\n                        onChange={(e) => this.setState({ yAxisLabelType: e.target.value }, this.initialize)}\r\n                    >\r\n                        <option value='pitch'>MIDI note</option>\r\n                        <option value='note'>Note name</option>\r\n                    </select>\r\n                    <button\r\n                        title='Toggles between showing the whole time or a selection in the lower part'\r\n                        onClick={() => this.setState({ showAllTime: !this.state.showAllTime })}\r\n                    >\r\n                        <FontAwesomeIcon icon={this.state.showAllTime ? faToggleOn : faToggleOff} />&nbsp;\r\n                        Show whole time\r\n                    </button>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import React, { Component } from 'react';\r\nimport './style/App.css';\r\nimport MidiParser from 'midi-parser-js';\r\nimport PitchTimeChart from './components/PitchTimeChart';\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faGithub } from '@fortawesome/free-brands-svg-icons';\r\nimport { preprocessMidiFileData } from 'musicvis-lib';\r\n\r\n\r\nexport default class App extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            viewSize: {\r\n                outerWidth: 800,\r\n                outerHeight: 600\r\n            },\r\n            midiFileData: [],\r\n            timeSelection: null\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        // Scale layout to current screen size\r\n        window.addEventListener('resize', this.onResize, false);\r\n        this.onResize();\r\n\r\n        // select the INPUT element that will handle\r\n        // the file selection.\r\n        let source = document.getElementById('filereader');\r\n        // provide the File source and a callback function\r\n        const _this = this;\r\n        MidiParser.parse(source, function (obj) {\r\n            try {\r\n                const parsed = preprocessMidiFileData(obj);\r\n                const parts = parsed.parts.map(d => d.noteObjs);\r\n                _this.setState({ midiFileData: parts });\r\n            } catch (e) {\r\n                alert('Invalid MIDI file or wrong format!');\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the size state when the window size changes\r\n     * so views can react and redraw\r\n     */\r\n    onResize = () => {\r\n        this.setState({\r\n            viewSize: {\r\n                outerWidth: Math.floor(window.innerWidth - 20),\r\n                outerHeight: Math.floor(window.innerHeight - 200)\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Changes the current time selection\r\n     * @param {number[]} timeSelection [start, end] in seconds\r\n     */\r\n    setTimeSelection = (timeSelection) => {\r\n        this.setState({ timeSelection, similarSections: [] });\r\n    };\r\n\r\n    render() {\r\n        const s = this.state;\r\n        return (\r\n            <div className={`App dark`} >\r\n                <div className='fileSelection'>\r\n                    <input\r\n                        className='fileInput'\r\n                        type='file'\r\n                        id='filereader'\r\n                    />\r\n                </div>\r\n                <PitchTimeChart\r\n                    name='Note-Time Chart'\r\n                    viewSize={s.viewSize}\r\n                    midiFileData={s.midiFileData}\r\n                    timeSelection={s.timeSelection}\r\n                    setTimeSelection={this.setTimeSelection}\r\n                />\r\n                <div className='githubLink'>\r\n                    <a href='https://github.com/fheyen/midi-pianoroll'>\r\n                        <FontAwesomeIcon icon={faGithub} />&nbsp;\r\n                        https://github.com/fheyen/midi-pianoroll\r\n                    </a>\r\n                </div>\r\n            </div >\r\n        );\r\n    }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}